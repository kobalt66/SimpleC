- Variables -

    Different types:
    (var [variable], byt [byte], chr [character], str [string], int [integer], flt [floating point], dbl [double], bol [boolean], typ [type])

    Define variables : [variable_type variable_name = value]
    
    > str text = "Hello";
    > int a = 10;
    > flt b = 5.5;
    > ...
    > var a = 5 | "s" | 's' | 0.2;
    > typ Type = var; | typ Type = int | ...

    -> Var can be anything. The other variable types have to have a value with their type.



- Operations -

    + : Adds number or strings together > 1 + 1 = 2 | 1 + a = 2 (if a = 1) | "Hel" + "lo" = "Hello" | a++; <=> a += 1;

    += : Adds onto a variable           > a += 1; <=> a = a + 1;

    ++ : Adds 1 onto a variable         > a++; <=> a = a + 1;
    
    - : Subtracts numbers               > -1 - 1 = -2 | 1 - 1 = 0 | 1 - a = 0 (if a = 1) | a--; <=> a -= 1;

    -= : Subtracts from a variable      > a -= 1; <=> a = a - 1;

    -- : Subtracts 1 from a variable    > a--; <=> a = a - 1;
    
    / : Divides numbers                 > 1 / 2 = 0.5 | 1 / a = 0.5 (if a = 2)

    /= : Divides from a variable        > a /= 1; <=> a = a / 1;
    
    * : Multiplies numbers or strings   > 1 * 2 = 2 | 1 * a = 2 (if a = 2) | "a" * 5 = "aaaaa"

    *= : Multiplies onto a variable     > a *= 1; <=> a = a * 1;

    = : Setting a variable              > int a = 1 | str a = "";
    
    % : Modulus opperation              > 2 % 2 = 0 | 3 % 2 = 1 | 2 % a = 0 (if a = 2)
    
    ^ : To the power of n               > 2^2 = 4 | 2^a = 3 (if a = 2) 
    
    ? : Comparing numbers or strings    > 2.2 ? 2 = false | "a" ? "a" = true | (Short if-statement) > bol check = "a" ? 1

    ! : Deny what comes next            > !(2 ? 3) = true (normaly 2 ? 3 = false)
    
    < : Less than                       > 1 < 2 = true | 2 < 1 = false
    
    > : Greater than                    > 2 > 1 = true | 1 > 2 = false
    
    <= : Less or equal than             > 2 <= a = true (if a = 3 | 2)
    
    >= : Greater or equal than          > 2 >= a = true (if a = 1 | 2)

    >> : Used in simple line statements > int check = 1 <= a >> 100 : 50; | each: obj in someList >> ...;

    . : Used to access public variables > someClass.var1 | someStruct.a
        from classes/ structs or 
        something else


    Overriding Operations:

        override operation(var a, var b)[+]
        {
            return a - b;
        }

    ->  The operator should stand right behind the parameters inside of '[operator]'
        The parameters' type should allways be 'var' because some operations can deal with different variable types!
        The return just returns the result of the overriden operation. It could get asigned to a variable but doesn't have to.
        The new defined operation only applies for the class the operation is nested in!
        
        override SomeClass::someFunction(var a, var b)[void]
        {
            ...
        }

    ->  The funtion of a class can be accessed in an override function by saying 'SomeClass::someFunction'
        The function's arguments have to be the same as before just like the returntype
        The returntype has to be inside '[returntype]'
        The overriden function will only be overriden for the script the override function is being called

    Convert into type:

        var a = (int)1.2; > round 1.2 to 1
        (!will only work with predefined types for now!)


- Lists -

    > int[] list = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }     (list has a lenght of 10)
    > int[] list = int[5];                              (list has a lenght of 5)
    > list[1] + 1 = 2 (return the value of the index 1)


- Keywords -

    (Variables): All the variable types are keywords            > (var, flt, int, ...)

    (Statements): All the statements are keywords               > (for, while, if, elif, else, ...)

    class: Used to define a class that holds functions          > private class someClass { ... }

    struct: Used to define a structure like a vector            > struct someStruct { int a = 1; } (variables are allways public: no public, private, const, ...)
            (It's basically a simple class)
            (It's available anywhere the script is included)
     
    public: Used for functions or classes to determin           > public void someFunction(var a) { ... }
            if they are publicly available              

    private: Used for functions or classes to determin          > public void someFunction(var a) { ... }       
             if they are not publicly available

    protected: Prevents a function from getting overriden       > public protected void someFunction(var a) { ... }

    const: Defines a variable that cannot be changes            > const int a = 1; (a = 2; doesn't work)

    static: Defines a class that can be accessed without        > public static class someClass { ... }
            declaring the class itself (it cannot be declared!)
    
    void: A void function doesn't return any value              > private void someFunction { return; } (return 0; doesn't work)

    override: Used to override non protected and none static    > override someFunction(var a) { ... } (only applies for the class the operation is nested in!)
              functions

    return: Returns a result of the function. Can be called at  > { return a ? 1 >> true : false; } (can only return a value with the return type of the function)
            any time

    continue: Used to skip tasks inside of a while/for loop     > for (int i = 0; i < a; i++) { if (i > a) continue; else return; }

    break: Used to break out of a while/for loop                > while (a ? 1) { a++; if (a ? 0) break; }

    sizeof: Gets the size of a variable of class in byt         > byt size = sizeof(someClass); | byt size = sizeof(a);

    typeof: Gets the type of a variable or class in typ         > typ t = typeof(someClass); | typ t = typeof(a);

    lenghtof: Gets the lenght of a list                         > int len = lenghtof(list);

    null: If a variable is unsigned it's null(nothing)          > int i; (i = null)

    false: A boolean expression to deny a condition             > 1 ? 2 = false (1 ? 2 is not true)

    true: A boolean expression to affirm a condition            > !(2 ? 1) = true (2 ? 1 is not (not) false: so it's true)

    this: It refers to it's class                               > class a { int i; void b(i) { this.i } } (i itself could be a the parameter of b. Though 'this' is pointing to class a)

    using: Get accesss to a namespace                           > namespace space { ... } class a { using space; } (class a has now access to all the stuff inside the namespace 'space')

    each: Used in for loops to loop through all the elements    > for (each: obj in someList) { ... } | each: obj in someList >> ...;
          in a list


-- Statements --
    
    - If-Statements -

        Short if-statement:
            
            bol check = "a" ? 1 >> true : false; | bol check = "a" ? 1; | int check = 1 <= a >> 100 : 50;

        Normal if-statement:

            if (... | ... & ... | (... | ...))      or      if (... | ... & ... | (... | ...))
            {                                                   ...;
                ...;                                        elif (...)
            }                                                   ...;                
            elif (...)                                      else
            {                                                   ...;
                ...
            }
            else
            {
                ...;
            }

        ->  There can be complex conditions inside an if-statement.
            An if-statement doesn't necessary need to have { }

    - While-Statements -
            
        while (...)             do
        {                       {
            ...         or          ...
        }                       } while (...)

    - For-Statements -
            
        for (int i = 0; i < (sizoOfSomething); i++)
        {
            ...
        }

        for (each: obj in someList)
        {
            ...
        }

        or
        
        (Maybe)
        each: obj in someList >> ...;

- Constructures -

    private class someClass
    {
        private int a;
        private str b;

        constructor(int a, str b)
            : a(a), b(b)
        {
            ...
        }
        constructor(int a) : a(a)
        {
            b = 0;
        }
        constructor(int a, str b)
        {
            this.a = a;
            this.b = b;
        }
    }

    struct someStruct
    {
        int a;
        str b;

        constructor(int a, str b) : a(a), b(b)
        {
            
        }  
    }

    (Calling the constructors) > someStruct new = someStruct(1, "a"); | someClass new = someClass(1);
    (If no constructor exists) > someClass new = someClass();

    ->  The constructor is allways public, as long as the class/struct is public too.
        A constructor can be build up in various ways.


- namespaces -

    namespace someNameSpace
    {
        namespace otherSpace { ... }
        public class a { ... }
    }

    private class program
    {
        using someNameSpace;
        using someNameSpace.otherSpace;
        
        private function void main()
        {
            var newA = a();
        }
    }

    ->  The namespace 'protect' a class/struct from the outside script.
        By using the namespace in a class, the class gets access to the namespace.
        One could also put the class inside the namespace.
        Namespaces can be nested!
        Namespaces can be in different scripts using the same namespace name:
        By that the content of one namespace can grow bigger through out many scripts.
        Use 'var' to define a class. Type of 'var' is unsigned so it can have any other type!


- libraries -

    #lib = "testLib"

    ->  Put this at the top of a script. Nothing can override the functions inside that script but the stuff in the library itself.
        Libraries can be extended through out a lot of different scripts. They all can interact with each others classes and functions like the usual way:
        (overriding is possible between scripts in the same library)

    -> Get access to a library:

        class a
        {
            using <testLib>
            ...
        }

        Just like the namespaces, the libraries have to be declared inside the class.
        The library name has to be inside '<>' and doesn't end with ';'.


- MetaCode -

    A way of determining argument or conditions besides SimpleC:

        - Allways starts with '#'
        - Then the argument/ statement

    #lib = "libname"    > for defining a library

    #define SOMETHING 0 > define metacode variables 

    #metif SOMETHING    > (metacode if) executes the code if the the metacode condition is true
    
    #metelif SOMETHING2 > (metacode else if) executes the code if the the metacode condition is true

    #metelse            > (metacode else) executes the code if non of the previous conditions are true

    #metendif           > determins where the metacode if-statement end's
    
    ->  The metacode variables can only be accessed by another script if the script uses the namespace or
        uses the script as a library!
    
    -> There will be predefined metacode variables in the standart libraries
